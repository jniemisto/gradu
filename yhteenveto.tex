\section{Yhteenveto}

Android-sovellukset koostuvat Android-kohtaisista komponenteista: aktiviteeteista, palveluista ja sisällöntarjoajista, sekä tavallisista Java-luokista. Aktiviteetti kuvaa käyttäjälle näkyvää näkymää. Palvelut taas on tarkoitettu pitkäkestoisten taustaoperaatioiden suoritukseen. Sisällöntarjoajat tarjoavat rajapinnan sovelluksen tarvitsemaan tietoon ja mahdollistavat sovellustenvälisen tietojenvaihdon.

Androidin arkkitehtuuri on vahvasti tapahtumapohjaista. Aktiviteetit ja palvelut toteuttavat takaisinkutsumetodit komponenttien elinkaaren hallintaan. Komponentit eivät ole suoraan yhteydessä toisiinsa vaan niiden välillä kommunikoidaan tapahtumapohjaisilla aikeilla, jotka järjestelmä välittää vastaanottavalle komponentille.

Android-sovellusten testaamiseen on kehitetty runsaasti testaustyökaluja. Jo Androidin mukana tulevat työkalut tarjoavat varsin kattavan työkaluvalikoiman Android-sovellusten testaamiseen ohjelmistotuotantoprosessin eri vaiheissa. Tämän lisäksi kolmannen osapuolen kehittämät testaustyökalut, kuten Robolectric ja Robotium, täydentävät Googlen kehittämiä testaustyökaluja.

Tässä tutkielmassa vertailtiin Androidin omia ja kolmansien osapuolien yksikkö- ja toiminnallisen testauksen työkaluja. Nämä työkalut valitsin huomion kohteeksi, koska toiminnallinen ja yksikkötestaus ovat yleisimmät testauksen muodot mobiilisovelluksia kehitettäessä ja työkaluvalikoima on myös monipuolisin. Toiminnallinen ja yksikkötestaus ovat myös useimmiten automatisoituja testaamisen vaiheita.

Yksikkötestauksessa haasteita tuo se, että vaikka Android-sovelluksia ohjelmoidaan Javalla, Androidin kirjastoluokat eivät toimi suoraan Javan omassa virtuaalikoneessa, vaan testit on ajettava Dalvik-ajoympäristössä emulaattorilla tai Android-laitteessa. Tämä hidastaa testien ajamista. Robolectric-yksikkötestaustyökalu mahdollistaa yksikkötestien ajamisen suoraan Javan virtuaalikoneella. 

Robolectric osoittautui toimivaksi vaihtoehdoksi Androidin omalle yksikkötestityökalulle. Sen käyttö oli käytännössä yhtä helppoa ja testien ajoaika oli moninkerroin nopeampi kuin Androidin omien yksikkötestien emulaattorissa. Itse testikoodista tuli kummallakin työkalulla lähes samanlaista, eikä testien kirjoittamiseen tarvittu kovin paljoa Android-spesifiä osaamista. Testattavien komponenttien alustus oli Robolectricillä jopa helpompaa, koska konstruktoreja saattoi kutsua suoraan testikehyksen tarjoamien alustusmetodien sijaan. Toisaalta aina ei voinut tietää, mitä metodeita eri luokkien valmiit varjototeutukset tarjoavat. Tämä oli selkeämpää Androidin omaa yksikkötestikehystä käytettäessä. Toisaalta Robolectric tarjoaa mahdollisuuden kirjoittaa itse omia varjoluokkia, joissa voi toteuttaa tynkiä Androidin kirjastoluokkien toiminnalle. 

Molemmilla yksikkötestitavoilla oli myös helppo käyttää jäljittelijäkehystä testeissä. Mockito toimi suoraan yhdessä Robolectricin kanssa ja Android-emulaattorissa ajaminenkin onnistui ilman suurempia ongelmia.

Suurin ero työkalujen välillä oli ajonopeuksessa. Robolectric lunasti lupauksensa nopeista testeistä; Robolectric-testit ajautuivat yli 25 kertaa nopeammin kuin emulaattorissa ajetut AndroidUnitTestit. Lisäksi AndroidUnitTestillä ajettaessa ensimmäisen testinkin ajautuminen pienellä testiohjelmalla kesti yli puoli minuuttia, joten testilähtöinen ohjelmointi AndroidUnitTestiä käyttäen on käytännössä toivottoman hidasta.

Yksikkötestauksessa pohdin Android-sovelluksen aktiviteettien yksikkötestauksen mielekkyyttä. Hyvin rakennetussa sovelluksessa sovelluslogiikka on eriytetty käyttöliittymälogiikasta omiin luokkiinsa, joten sovelluslogiikan yksikkötestaus onnistuu myös tavallisella JUnitilla. Sovelluslogiikassa useimmiten on myös testauksen kannalta tärkeimmät osat. Käyttöliittymälogiikan yksikkötestausta tehokkaampaa voisi sen sijaan olla suora toiminnallinen testaus käyttöliittymän kautta. En testannut tässä tutkielmassa muita Androidin peruskomponentteja, joten on mahdollista, että palveluiden tai sisällöntarjoajien yksikkötestaus olisi aktiviteettien yksikkötestausta mielekkäämpää.

Toiminnallisen testauksen työkaluista vertailtiin Uiautomatoria, Robotiumia ja Troydia. Kukin näistä on toimintatavaltaan hieman erilainen. 

Uiautomator on Androidin mukana tuleva työkalu. Uiautomator-testien kirjoittaminen on melko verboosia, mutta siihen liittyvä käyttöliittymän analysoiva Uiautomatorviewer tekee testien kirjoittamisesta helppoa ilman, että sovelluksen lähdekoodia tarvitsee tuntea. Uiautomatorin suurin puute on, että se toimii vain uusimmissa Android-versioissa, joten regressiotestaus vanhempien laitteiden toiminnan varmistamiseksi ei sillä onnistu.

Troyd taas toimii vain Androidin versiolla 2.3.6. Sen erikoisuus on nauhoitusskripti, jonka avulla testiä kirjoitettaessa näkee jatkuvasti sovelluksen tilan testin kussakin vaiheessa. Troydilla testaus on korkeimmalla abstraktiotasolla testatuista työkaluista ja sillä kirjoitetut testit ovat hyvin tiiviitä. Troyd kuitenkin tarvitsisi runsaasti viimeistelyä, jotta sen käyttöä voisi suositella. Myös testien suoritusaika oli kymmenen kertaa hitaampaa kuin muilla testatuilla työkaluilla.

Robotium osoittautui hyväksi toiminnallisen testauksen työkaluksi, joka toimii vakaasti Androidin eri versioilla, joskin testien kirjoittaminen oli hieman Uiautomatoria tai Troydia haastavampaa. Testit olivat kuitenkin suhteellisen tiiviitä. Testien ajoaika oli Robotiumilla ja Uiautomatorilla suunnilleen yhtä nopeaa. 

Androidin testaustyökalujen tilanne kokonaisuudessaan on varsin hyvä. Google on ottanut testauksen huomioon Androidia kehittäessä ja tarjoaa Androidin kehitystyökalujen mukana melko kattavan paketin erilaisia testityökaluja ohjelmistotuotantoprosessin eri vaiheissa. Tämän lisäksi kolmansien osapuolien kehittämät testaustyökalut täydentävät Androidin omien testaustyökalujen aukkoja.